<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>サブレ・ビート・プロ (片手モード対応)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --accent-color: #8b7969;
            --particle-color: #f1c40f;
        }
        body {
            font-family: 'Noto Serif JP', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            -webkit-user-select: none; user-select: none;
            overflow: hidden;
        }
        .game-container { width: 100%; max-width: 400px; text-align: center; }
        h1 { font-family: 'Orbitron', sans-serif; font-size: 2em; margin: 0 0 15px 0; color: #fff; text-shadow: 0 0 10px #fff; }
        #canvas-wrapper { position: relative; width: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; }
        canvas { display: block; width: 100%; height: auto; background: linear-gradient(to bottom, #34495e, #2c3e50); cursor: pointer; }
        .info-panel { display: flex; justify-content: space-around; font-family: 'Orbitron', sans-serif; font-size: 1.2em; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: var(--text-color); font-size: 1.5em; text-align: center;
            background: rgba(44, 62, 80, 0.9);
            pointer-events: none;
        }
        #ui-layer.hidden { display: none; }
        #ui-layer p { margin: 0 0 20px 0; }
        .ui-button {
            font-family: 'Noto Serif JP', serif;
            font-size: 1em; padding: 15px 30px; border-radius: 8px;
            border: 2px solid var(--accent-color); background: transparent; color: #fff;
            cursor: pointer; pointer-events: auto; display: block;
            margin: 15px auto; width: 80%;
            transition: all 0.3s ease;
        }
        .ui-button:hover {
            background: var(--accent-color);
            transform: scale(1.05);
        }
        #feedback-text {
            position: absolute; top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-size: 3em; font-weight: bold;
            color: #fff; text-shadow: 0 0 15px var(--particle-color);
            opacity: 0; transition: all 0.3s;
        }
        #feedback-text.show { opacity: 1; transform: translateX(-50%) scale(1.2); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>サブレ・ビート・プロ</h1>
        <div class="info-panel">
            <div>SCORE: <span id="score">0</span></div>
            <div>COMBO: <span id="combo">0</span></div>
        </div>
        
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="ui-layer">
                <div id="song-select-view">
                    <p>プレイする曲を選んでください</p>
                    <button class="ui-button" data-song="sakusaku">サクサク冒険</button>
                    <button class="ui-button" data-song="mochimochi">もちもちリラックス</button>
                </div>
                <div id="style-select-view" style="display: none;">
                     <p>プレイスタイルを選んでください</p>
                    <button class="ui-button" data-style="left">左手でプレイ</button>
                    <button class="ui-button" data-style="right">右手でプレイ</button>
                    <button class="ui-button" data-style="tap">タップでプレイ</button>
                </div>
                <!-- ★★★ 修正点: UI表示用のコンテナを追加 ★★★ -->
                <div id="message-view" style="display: none;"></div>
                <div id="game-over-view" style="display: none;"></div>
            </div>
            <div id="feedback-text"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const uiLayer = document.getElementById('ui-layer');
        const songSelectView = document.getElementById('song-select-view');
        const styleSelectView = document.getElementById('style-select-view');
        const messageView = document.getElementById('message-view');
        const gameOverView = document.getElementById('game-over-view');
        const feedbackText = document.getElementById('feedback-text');
        
        canvas.width = 400;
        canvas.height = 600;

        const LANES = 5;
        const LANE_WIDTH = canvas.width / LANES;
        const NOTE_HEIGHT = 20;
        const JUDGEMENT_LINE_Y = canvas.height - 80;

        const beatmaps = {
            sakusaku: [
    { time: 2.764, lane: 0, type: 0 },
    { time: 3.282, lane: 1, type: 1 },
    { time: 3.744, lane: 4, type: 1 },
    { time: 4.314, lane: 2, type: 2 },
    { time: 4.858, lane: 3, type: 0 },
    { time: 6.025, lane: 4, type: 0 },
    { time: 6.719, lane: 3, type: 2 },
    { time: 7.715, lane: 1, type: 0 },
    { time: 8.189, lane: 3, type: 0 },
    { time: 8.761, lane: 2, type: 1 },
    { time: 9.091, lane: 4, type: 0 },
    { time: 9.315, lane: 0, type: 0 },
    { time: 9.666, lane: 3, type: 2 },
    { time: 10.126, lane: 1, type: 2 },
    { time: 10.145, lane: 4, type: 2 },
    { time: 10.583, lane: 4, type: 0 },
    { time: 11.257, lane: 3, type: 1 },
    { time: 11.257, lane: 4, type: 1 },
    { time: 12.031, lane: 1, type: 0 },
    { time: 13.056, lane: 2, type: 1 },
    { time: 13.886, lane: 4, type: 0 },
    { time: 14.453, lane: 3, type: 1 },
    { time: 14.823, lane: 1, type: 0 },
    { time: 15.678, lane: 0, type: 1 },
    { time: 16.282, lane: 4, type: 0 },
    { time: 16.865, lane: 3, type: 0 },
    { time: 19.28, lane: 2, type: 1 },
    { time: 19.704, lane: 1, type: 1 },
    { time: 20.182, lane: 4, type: 1 },
    { time: 21.132, lane: 1, type: 0 },
    { time: 21.67, lane: 3, type: 0 },
    { time: 22.202, lane: 4, type: 2 },
    { time: 22.852, lane: 3, type: 2 },
    { time: 24.081, lane: 1, type: 0 },
    { time: 24.683, lane: 4, type: 1 },
    { time: 25.239, lane: 3, type: 0 },
    { time: 25.602, lane: 1, type: 1 },
    { time: 26.053, lane: 2, type: 2 },
    { time: 26.485, lane: 4, type: 1 },
    { time: 26.903, lane: 1, type: 0 },
    { time: 27.365, lane: 3, type: 0 },
    { time: 27.968, lane: 2, type: 1 },
    { time: 28.03, lane: 0, type: 1 },
    { time: 28.295, lane: 4, type: 2 },
    { time: 28.433, lane: 1, type: 1 },
    { time: 28.824, lane: 3, type: 0 },
    { time: 29.246, lane: 2, type: 1 },
    { time: 29.86, lane: 3, type: 0 },
    { time: 29.861, lane: 4, type: 2 },
    { time: 31.27, lane: 4, type: 1 },
    { time: 31.595, lane: 4, type: 0 },
    { time: 31.858, lane: 1, type: 2 },
    { time: 32.489, lane: 3, type: 2 },
    { time: 33.067, lane: 4, type: 2 },
    { time: 33.656, lane: 3, type: 2 },
    { time: 34.562, lane: 1, type: 0 },
    { time: 34.889, lane: 1, type: 1 },
    { time: 34.917, lane: 4, type: 2 },
    { time: 34.962, lane: 0, type: 2 },
    { time: 35.497, lane: 3, type: 2 },
    { time: 35.792, lane: 1, type: 0 },
],
            mochimochi: [
    { time: 1.131, lane: 1, type: 1 },
    { time: 1.54, lane: 2, type: 2 },
    { time: 2.866, lane: 4, type: 0 },
    { time: 3.263, lane: 3, type: 2 },
    { time: 4.297, lane: 1, type: 2 },
    { time: 4.998, lane: 4, type: 0 },
    { time: 5.503, lane: 4, type: 0 },
    { time: 6.714, lane: 1, type: 1 },
    { time: 7.798, lane: 3, type: 1 },
    { time: 7.969, lane: 3, type: 2 },
    { time: 8.176, lane: 3, type: 0 },
    { time: 8.387, lane: 3, type: 0 },
    { time: 8.614, lane: 3, type: 2 },
    { time: 8.825, lane: 4, type: 0 },
    { time: 9.027, lane: 0, type: 1 },
    { time: 9.339, lane: 3, type: 1 },
    { time: 9.98, lane: 1, type: 2 },
    { time: 11.048, lane: 2, type: 1 },
    { time: 11.512, lane: 3, type: 0 },
    { time: 11.717, lane: 3, type: 1 },
    { time: 11.964, lane: 3, type: 1 },
    { time: 12.198, lane: 3, type: 0 },
    { time: 12.429, lane: 3, type: 2 },
    { time: 12.675, lane: 4, type: 1 },
    { time: 12.889, lane: 0, type: 1 },
    { time: 13.121, lane: 3, type: 0 },
    { time: 13.898, lane: 1, type: 2 },
    { time: 13.911, lane: 0, type: 0 },
    { time: 13.911, lane: 3, type: 2 },
    { time: 13.912, lane: 4, type: 0 },
    { time: 14.847, lane: 3, type: 0 },
    { time: 15.301, lane: 3, type: 1 },
    { time: 15.319, lane: 4, type: 1 },
    { time: 15.524, lane: 3, type: 0 },
    { time: 15.755, lane: 3, type: 0 },
    { time: 15.986, lane: 3, type: 2 },
    { time: 16.23, lane: 3, type: 2 },
    { time: 16.513, lane: 1, type: 0 },
    { time: 16.727, lane: 4, type: 1 },
    { time: 16.978, lane: 3, type: 0 },
    { time: 17.644, lane: 2, type: 0 },
    { time: 17.927, lane: 1, type: 1 },
    { time: 18.345, lane: 0, type: 2 },
    { time: 18.924, lane: 3, type: 2 },
    { time: 19.358, lane: 4, type: 2 },
    { time: 19.814, lane: 3, type: 0 },
    { time: 20.029, lane: 1, type: 1 },
    { time: 20.286, lane: 4, type: 0 },
    { time: 20.543, lane: 2, type: 2 },
    { time: 20.754, lane: 3, type: 2 },
    { time: 20.988, lane: 1, type: 0 },
    { time: 21.569, lane: 3, type: 2 },
    { time: 22.076, lane: 3, type: 0 },
    { time: 22.28, lane: 1, type: 0 },
    { time: 22.483, lane: 4, type: 0 },
    { time: 22.766, lane: 2, type: 0 },
    { time: 23.248, lane: 3, type: 2 },
    { time: 23.439, lane: 1, type: 1 },
    { time: 23.667, lane: 4, type: 2 },
    { time: 23.886, lane: 0, type: 0 },
    { time: 24.136, lane: 3, type: 2 },
    { time: 24.347, lane: 1, type: 0 },
    { time: 24.643, lane: 2, type: 0 },
    { time: 25.404, lane: 4, type: 2 },
    { time: 25.595, lane: 1, type: 2 },
    { time: 25.86, lane: 3, type: 2 },
    { time: 26.32, lane: 2, type: 1 },
    { time: 26.829, lane: 3, type: 1 },
    { time: 27.556, lane: 3, type: 0 },
    { time: 28.034, lane: 1, type: 0 },
    { time: 28.239, lane: 4, type: 0 },
    { time: 28.485, lane: 0, type: 2 },
    { time: 29.23, lane: 3, type: 2 },
    { time: 30.212, lane: 2, type: 2 },
    { time: 30.687, lane: 0, type: 0 },
    { time: 30.689, lane: 2, type: 2 },
    { time: 31.54, lane: 2, type: 1 },
    { time: 31.548, lane: 0, type: 2 },
    { time: 32.239, lane: 3, type: 1 },
    { time: 32.255, lane: 4, type: 0 },
    { time: 32.903, lane: 3, type: 2 },
    { time: 33.938, lane: 3, type: 1 },
    { time: 33.949, lane: 4, type: 2 },
    { time: 34.355, lane: 0, type: 1 },
    { time: 34.361, lane: 2, type: 2 },
    { time: 34.37, lane: 3, type: 0 },
    { time: 34.388, lane: 4, type: 0 },
    { time: 35.336, lane: 0, type: 2 },
    { time: 35.34, lane: 2, type: 2 },
    { time: 35.341, lane: 3, type: 0 },
    { time: 35.357, lane: 4, type: 0 },
    { time: 36.064, lane: 1, type: 2 },
]
        };
        
        const keyMaps = {
            left: { 'a': 0, 's': 1, 'd': 3, 'f': 4, ' ': 2 },
            right: { 'j': 0, 'k': 1, 'l': 3, ';': 4, ' ': 2 }
        };
        let currentKeyMap = null;

        let audio, beatmap;
        let notes = [], score = 0, combo = 0, particles = [];
        let laneFlashes = [0, 0, 0, 0, 0];
        let isGameRunning = false, startTime = 0;
        const noteSpeed = 3;

        const SABLE_COLORS = {
            base: ['#607C5D', '#5D4037', '#F3E5AB'],
            light: ['#83b97e', '#8d6e63', '#fff5d6']
        };
        
        // ★★★ 修正点: init関数を正しく定義 ★★★
        function init() {
            score = 0; combo = 0; notes = []; particles = [];
            laneFlashes = [0, 0, 0, 0, 0];
            isGameRunning = false; startTime = 0; currentKeyMap = null;

            if(audio) {
                audio.pause();
                audio = null;
            }

            // UIを初期状態に戻す
            songSelectView.style.display = 'block';
            styleSelectView.style.display = 'none';
            messageView.style.display = 'none';
            gameOverView.style.display = 'none';
            uiLayer.classList.remove('hidden');

            updateUI();
            
            // ゲーム画面をクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLanes();
            drawJudgementLine();
        }

        function selectSong(songName) {
            audio = new Audio(`./${songName}.mp3`);
            audio.preload = "auto";
            beatmap = beatmaps[songName];
            if (!beatmap) return;
            
            // ★★★ 修正点: UI表示を安全な方法に変更 ★★★
            songSelectView.style.display = 'none';
            messageView.innerHTML = `<p>ロード中...</p>`;
            messageView.style.display = 'block';

            audio.addEventListener('canplaythrough', () => {
                messageView.style.display = 'none';
                styleSelectView.style.display = 'block';
            }, { once: true });
            
            audio.load();
        }

        function selectPlayStyle(style) {
            if (style === 'left' || style === 'right') {
                currentKeyMap = keyMaps[style];
            } else {
                currentKeyMap = null; // タップモード
            }
            startGame();
        }

        function startGame() {
            score = 0; combo = 0; notes = [];
            isGameRunning = true;
            uiLayer.classList.add('hidden');
            beatmap.forEach(createNote);
            audio.currentTime = 0;
            audio.play();
            startTime = performance.now();
            gameLoop();
        }

        function createNote(noteData) {
            notes.push({ ...noteData, y: -NOTE_HEIGHT, spawnTime: noteData.time - (JUDGEMENT_LINE_Y / (60 * noteSpeed)), isHit: false });
        }

        function gameLoop() {
            if (!isGameRunning) return;
            const currentTime = (performance.now() - startTime) / 1000;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLanes();
            drawJudgementLine();
            notes.forEach(note => {
                if (!note.isHit) {
                    note.y = (currentTime - note.spawnTime) * 60 * noteSpeed - NOTE_HEIGHT;
                    drawNote(note);
                    if (note.y > canvas.height) { note.isHit = true; showFeedback('MISS'); resetCombo(); }
                }
            });
            notes = notes.filter(note => !note.isHit || note.y <= canvas.height);
            particles.forEach((p, i) => { p.update(); p.draw(); if (p.alpha <= 0) particles.splice(i, 1); });
            if (audio.ended) {
                gameOver();
            } else {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // ★★★ 修正点: ゲームオーバー処理を安全な方法に変更 ★★★
        function gameOver() {
            isGameRunning = false;
            gameOverView.innerHTML = `<div><p>FINISH!</p><p>SCORE: ${score}</p><button class="ui-button" id="restartButton">曲選択に戻る</button></div>`;
            
            songSelectView.style.display = 'none';
            styleSelectView.style.display = 'none';
            messageView.style.display = 'none';
            gameOverView.style.display = 'block';
            uiLayer.classList.remove('hidden');

            document.getElementById('restartButton').addEventListener('click', init);
        }
        
        function drawLanes() {
            for (let i = 0; i < LANES; i++) {
                ctx.fillStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.2)';
                ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                if (laneFlashes[i] > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${laneFlashes[i]})`;
                    ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                    laneFlashes[i] -= 0.05;
                }
            }
        }

        function drawJudgementLine() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0, JUDGEMENT_LINE_Y, canvas.width, 3);
        }

        function drawNote(note) {
            const x = note.lane * LANE_WIDTH;
            const colorBase = SABLE_COLORS.base[note.type];
            const colorLight = SABLE_COLORS.light[note.type];
            ctx.fillStyle = colorBase;
            ctx.fillRect(x + 5, note.y, LANE_WIDTH - 10, NOTE_HEIGHT);
            ctx.fillStyle = colorLight;
            ctx.fillRect(x + 10, note.y + 5, LANE_WIDTH - 20, NOTE_HEIGHT - 10);
        }

        function handleInput(lane) {
            if (!isGameRunning) return;
            const targetTime = audio.currentTime;
            let bestNoteIndex = -1;
            let minDiff = Infinity;
            notes.forEach((note, index) => {
                if (note.lane === lane && !note.isHit) {
                    const diff = Math.abs(note.time - targetTime);
                    if (diff < minDiff) { minDiff = diff; bestNoteIndex = index; }
                }
            });
            laneFlashes[lane] = 0.5;
            if (bestNoteIndex !== -1 && minDiff < 0.3) {
                const note = notes[bestNoteIndex];
                note.isHit = true;
                if (minDiff < 0.1) { score += 300 + combo; combo++; showFeedback('PERFECT'); }
                else if (minDiff < 0.2) { score += 100; combo++; showFeedback('GOOD'); }
                else { resetCombo(); showFeedback('BAD'); }
                createParticles(lane * LANE_WIDTH + LANE_WIDTH / 2, JUDGEMENT_LINE_Y);
            }
            updateUI();
        }
        
        function resetCombo() { combo = 0; }
        function updateUI() { scoreEl.textContent = score; comboEl.textContent = combo; }

        function showFeedback(text) {
            feedbackText.textContent = text;
            feedbackText.className = 'show';
            setTimeout(() => feedbackText.classList.remove('show'), 300);
        }
        
        function createParticles(x, y) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5 - 2,
                    alpha: 1, color: `hsl(${Math.random() * 60 + 30}, 100%, 70%)`,
                    update() { this.x += this.vx; this.y += this.vy; this.alpha -= 0.04; },
                    draw() {
                        ctx.globalAlpha = this.alpha;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                });
            }
        }

        // --- Input Handling ---
        document.addEventListener('keydown', (e) => {
            if (currentKeyMap) {
                const key = e.key === ' ' ? ' ' : e.key.toLowerCase();
                if (currentKeyMap[key] !== undefined) {
                    handleInput(currentKeyMap[key]);
                }
            }
        });

        function handlePointerInput(event) {
            event.preventDefault();
            if (currentKeyMap) return; // キーボードモード中はタップ無効
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const touchX = clientX - rect.left;
            const lane = Math.floor(touchX / (rect.width / LANES));
            if (lane >= 0 && lane < LANES) handleInput(lane);
        }
        
        canvas.addEventListener('touchstart', handlePointerInput, { passive: false });
        canvas.addEventListener('mousedown', handlePointerInput);
        
        // --- UI Initialization ---
        document.querySelectorAll('#song-select-view .ui-button').forEach(button => {
            button.addEventListener('click', (e) => selectSong(e.target.dataset.song));
        });
        document.querySelectorAll('#style-select-view .ui-button').forEach(button => {
            button.addEventListener('click', (e) => selectPlayStyle(e.target.dataset.style));
        });
        
        // ★★★ 修正点: 最後にinit()を呼び出す ★★★
        init();
    });
    </script>
</body>
</html>
