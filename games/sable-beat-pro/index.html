<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>サブレ・ビート・プロ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --accent-color: #8b7969;
            --particle-color: #f1c40f;
        }
        body {
            font-family: 'Noto Serif JP', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            -webkit-user-select: none; user-select: none;
            overflow: hidden;
        }
        .game-container { width: 100%; max-width: 400px; text-align: center; }
        h1 { font-family: 'Orbitron', sans-serif; font-size: 2em; margin: 0 0 15px 0; color: #fff; text-shadow: 0 0 10px #fff; }
        #canvas-wrapper { position: relative; width: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; }
        canvas { display: block; width: 100%; height: auto; background: linear-gradient(to bottom, #34495e, #2c3e50); }
        .info-panel { display: flex; justify-content: space-around; font-family: 'Orbitron', sans-serif; font-size: 1.2em; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: var(--text-color); font-size: 1.5em; text-align: center;
            background: rgba(44, 62, 80, 0.9);
            pointer-events: none;
        }
        #ui-layer.hidden { display: none; }
        #ui-layer p { margin: 0 0 20px 0; }
        .song-select-button {
            font-family: 'Noto Serif JP', serif;
            font-size: 1em; padding: 15px 30px; border-radius: 8px;
            border: 2px solid var(--accent-color); background: transparent; color: #fff;
            cursor: pointer; pointer-events: auto; display: block;
            margin: 15px auto; width: 80%;
            transition: all 0.3s ease;
        }
        .song-select-button:hover {
            background: var(--accent-color);
            transform: scale(1.05);
        }
        #feedback-text {
            position: absolute; top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-size: 3em; font-weight: bold;
            color: #fff; text-shadow: 0 0 15px var(--particle-color);
            opacity: 0; transition: all 0.3s;
        }
        #feedback-text.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>サブレ・ビート・プロ</h1>
        <div class="info-panel">
            <div>SCORE: <span id="score">0</span></div>
            <div>COMBO: <span id="combo">0</span></div>
        </div>
        
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="ui-layer">
                <div>
                    <p>プレイする曲を選んでください</p>
                    <button class="song-select-button" data-song="sakusaku">サクサク冒険</button>
                    <button class="song-select-button" data-song="mochimochi">もちもちリラックス</button>
                </div>
            </div>
            <div id="feedback-text"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const uiLayer = document.getElementById('ui-layer');
        const feedbackText = document.getElementById('feedback-text');
        
        canvas.width = 400;
        canvas.height = 600;

        const LANES = 4;
        const LANE_WIDTH = canvas.width / LANES;
        const NOTE_HEIGHT = 20;
        const JUDGEMENT_LINE_Y = canvas.height - 80;

        // ==================================================================
        // ★★★ ここに、事前に解析した譜面データを保存します ★★★
        // ==================================================================
        const beatmaps = {
            sakusaku: [
    { time: 3.119, lane: 3, type: 2 },
    { time: 3.675, lane: 1, type: 1 },
    { time: 4.296, lane: 2, type: 2 },
    { time: 4.869, lane: 3, type: 2 },
    { time: 5.158, lane: 0, type: 1 },
    { time: 5.526, lane: 2, type: 2 },
    { time: 5.642, lane: 1, type: 2 },
    { time: 5.957, lane: 3, type: 0 },
    { time: 6.424, lane: 2, type: 0 },
    { time: 6.93, lane: 1, type: 0 },
    { time: 7.309, lane: 2, type: 1 },
    { time: 7.774, lane: 2, type: 0 },
    { time: 8.139, lane: 3, type: 2 },
    { time: 8.835, lane: 0, type: 2 },
    { time: 9.166, lane: 2, type: 2 },
    { time: 9.287, lane: 1, type: 0 },
    { time: 9.666, lane: 3, type: 2 },
    { time: 10.122, lane: 2, type: 0 },
    { time: 10.582, lane: 1, type: 0 },
    { time: 11.185, lane: 0, type: 2 },
    { time: 11.543, lane: 2, type: 2 },
    { time: 11.727, lane: 3, type: 1 },
    { time: 12.114, lane: 2, type: 1 },
    { time: 13.03, lane: 0, type: 1 },
    { time: 13.936, lane: 2, type: 2 },
    { time: 14.463, lane: 3, type: 2 },
    { time: 15.071, lane: 1, type: 2 },
    { time: 15.661, lane: 0, type: 2 },
    { time: 16.239, lane: 2, type: 2 },
    { time: 16.877, lane: 3, type: 2 },
    { time: 17.334, lane: 1, type: 2 },
    { time: 17.794, lane: 2, type: 2 },
    { time: 18.377, lane: 3, type: 0 },
    { time: 18.696, lane: 0, type: 0 },
    { time: 18.849, lane: 2, type: 2 },
    { time: 19.025, lane: 1, type: 1 },
    { time: 19.217, lane: 3, type: 1 },
    { time: 19.404, lane: 0, type: 2 },
    { time: 21.153, lane: 2, type: 0 },
    { time: 21.681, lane: 3, type: 0 },
    { time: 22.251, lane: 1, type: 0 },
    { time: 22.877, lane: 1, type: 0 },
    { time: 23.477, lane: 3, type: 2 },
    { time: 24.033, lane: 1, type: 2 },
    { time: 24.325, lane: 2, type: 1 },
    { time: 26.475, lane: 0, type: 1 },
    { time: 26.994, lane: 2, type: 0 },
    { time: 27.43, lane: 3, type: 1 },
    { time: 28.003, lane: 1, type: 2 },
    { time: 28.285, lane: 2, type: 2 },
    { time: 28.449, lane: 0, type: 0 },
    { time: 28.62, lane: 3, type: 2 },
    { time: 29.12, lane: 3, type: 1 },
    { time: 30.713, lane: 1, type: 0 },
    { time: 31.266, lane: 0, type: 0 },
    { time: 33.101, lane: 2, type: 1 },
    { time: 33.697, lane: 3, type: 0 },
    { time: 34.301, lane: 2, type: 1 },
    { time: 34.478, lane: 1, type: 2 },
    { time: 34.801, lane: 0, type: 2 },
],
            mochimochi: [
    { time: 5.096, lane: 3, type: 0 },
    { time: 5.545, lane: 3, type: 2 },
    { time: 7.715, lane: 2, type: 2 },
    { time: 7.961, lane: 2, type: 2 },
    { time: 8.143, lane: 2, type: 2 },
    { time: 8.375, lane: 2, type: 0 },
    { time: 8.604, lane: 2, type: 0 },
    { time: 9.082, lane: 2, type: 0 },
    { time: 9.342, lane: 3, type: 0 },
    { time: 10.211, lane: 1, type: 1 },
    { time: 11.002, lane: 2, type: 2 },
    { time: 11.494, lane: 3, type: 0 },
    { time: 11.706, lane: 3, type: 2 },
    { time: 11.954, lane: 3, type: 0 },
    { time: 12.169, lane: 3, type: 1 },
    { time: 12.425, lane: 0, type: 2 },
    { time: 12.705, lane: 2, type: 0 },
    { time: 12.88, lane: 1, type: 2 },
    { time: 13.159, lane: 3, type: 2 },
    { time: 13.89, lane: 0, type: 0 },
    { time: 14.41, lane: 1, type: 2 },
    { time: 14.87, lane: 2, type: 1 },
    { time: 15.377, lane: 3, type: 0 },
    { time: 15.58, lane: 3, type: 2 },
    { time: 15.796, lane: 3, type: 1 },
    { time: 16.012, lane: 0, type: 0 },
    { time: 16.275, lane: 2, type: 0 },
    { time: 16.47, lane: 1, type: 0 },
    { time: 16.745, lane: 2, type: 2 },
    { time: 16.957, lane: 0, type: 2 },
    { time: 17.708, lane: 3, type: 1 },
    { time: 17.962, lane: 2, type: 1 },
    { time: 18.196, lane: 1, type: 1 },
    { time: 18.903, lane: 3, type: 0 },
    { time: 19.343, lane: 2, type: 1 },
    { time: 19.792, lane: 1, type: 1 },
    { time: 20.1, lane: 3, type: 0 },
    { time: 20.323, lane: 0, type: 1 },
    { time: 20.576, lane: 1, type: 2 },
    { time: 20.831, lane: 2, type: 1 },
    { time: 21.111, lane: 3, type: 2 },
    { time: 21.537, lane: 3, type: 2 },
    { time: 21.999, lane: 0, type: 2 },
    { time: 22.229, lane: 1, type: 2 },
    { time: 22.523, lane: 2, type: 1 },
    { time: 22.896, lane: 0, type: 0 },
    { time: 23.445, lane: 3, type: 1 },
    { time: 23.692, lane: 1, type: 2 },
    { time: 23.991, lane: 0, type: 1 },
    { time: 24.218, lane: 1, type: 2 },
    { time: 24.523, lane: 0, type: 0 },
    { time: 24.745, lane: 0, type: 2 },
    { time: 25.345, lane: 3, type: 0 },
    { time: 25.724, lane: 2, type: 2 },
    { time: 26.321, lane: 1, type: 0 },
    { time: 26.862, lane: 3, type: 1 },
    { time: 27.717, lane: 2, type: 1 },
    { time: 27.948, lane: 1, type: 2 },
    { time: 28.206, lane: 0, type: 0 },
    { time: 29.112, lane: 3, type: 0 },
    { time: 30.141, lane: 0, type: 1 },
    { time: 30.643, lane: 2, type: 1 },
    { time: 30.868, lane: 2, type: 0 },
    { time: 31.129, lane: 1, type: 2 },
    { time: 31.382, lane: 0, type: 1 },
    { time: 31.635, lane: 3, type: 1 },
    { time: 31.84, lane: 1, type: 0 },
    { time: 32.341, lane: 2, type: 0 },
    { time: 33.024, lane: 3, type: 2 },
    { time: 33.533, lane: 0, type: 1 },
    { time: 34.041, lane: 2, type: 1 },
    { time: 34.471, lane: 1, type: 2 },
    { time: 35.009, lane: 3, type: 2 },
    { time: 35.249, lane: 1, type: 1 },
    { time: 35.47, lane: 2, type: 1 },
    { time: 35.9, lane: 0, type: 0 },
    { time: 36.175, lane: 3, type: 2 },
    { time: 36.901, lane: 1, type: 0 },
    { time: 37.387, lane: 2, type: 0 },
]
        };

        let audio;
        let notes = [];
        let score = 0;
        let combo = 0;
        let particles = [];
        let laneFlashes = [0, 0, 0, 0];
        let isGameRunning = false;
        let startTime = 0;
        const noteSpeed = 3;

        const SABLE_COLORS = {
            base: ['#607C5D', '#5D4037', '#F3E5AB'],
            light: ['#83b97e', '#8d6e63', '#fff5d6']
        };

        function selectSong(songName) {
            // オーディオ要素を動的に生成
            audio = new Audio(`./${songName}.mp3`);
            audio.preload = "auto";
            
            // 譜面を選択
            const beatmap = beatmaps[songName];
            if (!beatmap) {
                console.error("譜面が見つかりません:", songName);
                return;
            }
            
            // 読み込みが完了してからゲームを開始
            audio.addEventListener('canplaythrough', () => {
                startGame(beatmap);
            }, { once: true });
            
            audio.load();
            uiLayer.innerHTML = `<p>ロード中...</p>`;
        }

        function startGame(beatmap) {
            score = 0;
            combo = 0;
            notes = [];
            isGameRunning = true;
            uiLayer.classList.add('hidden');

            beatmap.forEach(createNote);
            
            audio.currentTime = 0;
            audio.play();
            startTime = performance.now();
            gameLoop();
        }

        function createNote(noteData) {
            notes.push({
                ...noteData,
                y: -NOTE_HEIGHT,
                spawnTime: noteData.time - (JUDGEMENT_LINE_Y / (60 * noteSpeed)),
                isHit: false
            });
        }

        function gameLoop() {
            if (!isGameRunning) return;
            
            const currentTime = (performance.now() - startTime) / 1000;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLanes();
            drawJudgementLine();

            notes.forEach((note) => {
                if (!note.isHit) {
                    const timeSinceSpawn = currentTime - note.spawnTime;
                    note.y = timeSinceSpawn * 60 * noteSpeed - NOTE_HEIGHT;
                    drawNote(note);
                    if (note.y > canvas.height) {
                        note.isHit = true;
                        showFeedback('MISS');
                        resetCombo();
                    }
                }
            });
            
            notes = notes.filter(note => !note.isHit || note.y <= canvas.height);

            particles.forEach((p, i) => {
                p.update(); p.draw();
                if (p.alpha <= 0) particles.splice(i, 1);
            });

            if (audio.ended) {
                isGameRunning = false;
                uiLayer.innerHTML = `<div><p>FINISH!</p><p>SCORE: ${score}</p><button class="song-select-button" onclick="location.reload()">曲選択に戻る</button></div>`;
                uiLayer.classList.remove('hidden');
            } else {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function drawLanes() {
            for (let i = 0; i < LANES; i++) {
                ctx.fillStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.2)';
                ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                if (laneFlashes[i] > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${laneFlashes[i]})`;
                    ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                    laneFlashes[i] -= 0.05;
                }
            }
        }

        function drawJudgementLine() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0, JUDGEMENT_LINE_Y, canvas.width, 3);
        }

        function drawNote(note) {
            const x = note.lane * LANE_WIDTH;
            const colorBase = SABLE_COLORS.base[note.type];
            const colorLight = SABLE_COLORS.light[note.type];
            ctx.fillStyle = colorBase;
            ctx.fillRect(x + 5, note.y, LANE_WIDTH - 10, NOTE_HEIGHT);
            ctx.fillStyle = colorLight;
            ctx.fillRect(x + 10, note.y + 5, LANE_WIDTH - 20, NOTE_HEIGHT - 10);
        }

        function handleInput(lane) {
            if (!isGameRunning) return;
            const targetTime = audio.currentTime;
            let bestNoteIndex = -1;
            let minDiff = Infinity;

            notes.forEach((note, index) => {
                if (note.lane === lane && !note.isHit) {
                    const diff = Math.abs(note.time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestNoteIndex = index;
                    }
                }
            });

            laneFlashes[lane] = 0.5;

            if (bestNoteIndex !== -1 && minDiff < 0.3) {
                const note = notes[bestNoteIndex];
                note.isHit = true;
                if (minDiff < 0.1) { score += 300 + combo; combo++; showFeedback('PERFECT'); }
                else if (minDiff < 0.2) { score += 100; combo++; showFeedback('GOOD'); }
                else { resetCombo(); showFeedback('BAD'); }
                createParticles(lane * LANE_WIDTH + LANE_WIDTH / 2, JUDGEMENT_LINE_Y);
            }
            updateUI();
        }
        
        function resetCombo() { combo = 0; }
        function updateUI() { scoreEl.textContent = score; comboEl.textContent = combo; }

        function showFeedback(text) {
            feedbackText.textContent = text;
            feedbackText.className = 'show';
            setTimeout(() => feedbackText.classList.remove('show'), 300);
        }
        
        function createParticles(x, y) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5 - 2,
                    alpha: 1, color: `hsl(${Math.random() * 60 + 30}, 100%, 70%)`,
                    update() { this.x += this.vx; this.y += this.vy; this.alpha -= 0.04; },
                    draw() {
                        ctx.globalAlpha = this.alpha;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                });
            }
        }

        const keyMap = { 'd': 0, 'f': 1, 'j': 2, 'k': 3 };
        document.addEventListener('keydown', (e) => {
            if (keyMap[e.key] !== undefined) handleInput(keyMap[e.key]);
        });
        
        document.querySelectorAll('.song-select-button').forEach(button => {
            button.addEventListener('click', (e) => {
                selectSong(e.target.dataset.song);
            });
        });
    });
    </script>
</body>
</html>
