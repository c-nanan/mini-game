<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>サブレ・ビート・ツアー</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --accent-color: #8b7969;
            --particle-color: #f1c40f;
        }
        body {
            font-family: 'Noto Serif JP', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            -webkit-user-select: none; user-select: none;
            overflow: hidden;
        }
        .game-container { width: 100%; max-width: 400px; text-align: center; }
        h1 { font-family: 'Orbitron', sans-serif; font-size: 2em; margin: 0 0 15px 0; color: #fff; text-shadow: 0 0 10px #fff; }
        #canvas-wrapper { position: relative; width: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; }
        canvas { display: block; width: 100%; height: auto; background: linear-gradient(to bottom, #34495e, #2c3e50); cursor: pointer; }
        .info-panel { display: flex; justify-content: space-around; font-family: 'Orbitron', sans-serif; font-size: 1.2em; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: var(--text-color); font-size: 1.5em; text-align: center;
            background: rgba(44, 62, 80, 0.9);
            pointer-events: none;
        }
        #ui-layer.hidden { display: none; }
        #ui-layer p { margin: 0 0 20px 0; }
        .ui-button {
            font-family: 'Noto Serif JP', serif;
            font-size: 1em; padding: 15px 30px; border-radius: 8px;
            border: 2px solid var(--accent-color); background: transparent; color: #fff;
            cursor: pointer; pointer-events: auto; display: block;
            margin: 15px auto; width: 80%;
            transition: all 0.3s ease;
        }
        .ui-button:hover { background: var(--accent-color); transform: scale(1.05); }
        .ui-button:disabled { background: #555; border-color: #555; color: #888; cursor: not-allowed; }
        #feedback-text {
            position: absolute; top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-size: 3em; font-weight: bold;
            color: #fff; text-shadow: 0 0 15px var(--particle-color);
            opacity: 0; transition: all 0.3s;
        }
        #feedback-text.show { opacity: 1; transform: translateX(-50%, -50%) scale(1.2); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>サブレ・ビート・ツアー</h1>
        <div class="info-panel">
            <div>SCORE: <span id="score">0</span></div>
            <div>COMBO: <span id="combo">0</span></div>
        </div>
        
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="ui-layer">
                <div id="main-view"></div>
            </div>
            <div id="feedback-text"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const uiLayer = document.getElementById('ui-layer');
        const mainView = document.getElementById('main-view');
        const feedbackText = document.getElementById('feedback-text');
        
        canvas.width = 400;
        canvas.height = 600;

        const LANES = 5;
        const LANE_WIDTH = canvas.width / LANES;
        const NOTE_HEIGHT = 25;
        const JUDGEMENT_LINE_Y = canvas.height - 150;

        const masterBeatmaps = {
            sakusaku: [
                 { time: 2.762, lane: 1, type: 2 },
    { time: 3.264, lane: 2, type: 1 },
    { time: 3.72, lane: 4, type: 0 },
    { time: 4.27, lane: 4, type: 1 },
    { time: 5.693, lane: 4, type: 1 },
    { time: 7.317, lane: 0, type: 1 },
    { time: 7.745, lane: 1, type: 1 },
    { time: 8.169, lane: 2, type: 0 },
    { time: 10.116, lane: 4, type: 0 },
    { time: 10.557, lane: 3, type: 0 },
    { time: 12.07, lane: 2, type: 0 },
    { time: 12.388, lane: 1, type: 2 },
    { time: 14.491, lane: 4, type: 2 },
    { time: 14.786, lane: 3, type: 0 },
    { time: 16.844, lane: 1, type: 0 },
    { time: 17.35, lane: 3, type: 2 },
    { time: 17.799, lane: 4, type: 2 },
    { time: 18.693, lane: 3, type: 0 },
    { time: 19.3, lane: 1, type: 0 },
    { time: 19.732, lane: 0, type: 0 },
    { time: 21.017, lane: 3, type: 0 },
    { time: 21.648, lane: 0, type: 2 },
    { time: 21.668, lane: 1, type: 2 },
    { time: 21.669, lane: 3, type: 1 },
    { time: 21.671, lane: 4, type: 0 },
    { time: 22.84, lane: 2, type: 2 },
    { time: 24.076, lane: 3, type: 1 },
    { time: 24.562, lane: 4, type: 1 },
    { time: 25.248, lane: 1, type: 0 },
    { time: 25.887, lane: 3, type: 1 },
    { time: 26.463, lane: 4, type: 1 },
    { time: 26.481, lane: 3, type: 0 },
    { time: 26.942, lane: 3, type: 2 },
    { time: 27.414, lane: 2, type: 1 },
    { time: 27.979, lane: 1, type: 2 },
    { time: 28.896, lane: 3, type: 2 },
    { time: 29.346, lane: 1, type: 0 },
    { time: 31.256, lane: 3, type: 1 },
    { time: 31.615, lane: 2, type: 0 },
    { time: 33.67, lane: 3, type: 0 },
    { time: 33.981, lane: 2, type: 0 },
    { time: 34.883, lane: 4, type: 1 },
    { time: 35.495, lane: 1, type: 2 },
            ],
            mochimochi: [
               { time: 1.16, lane: 3, type: 2 },
    { time: 1.608, lane: 4, type: 2 },
    { time: 2.823, lane: 1, type: 0 },
    { time: 3.299, lane: 0, type: 0 },
    { time: 4.303, lane: 3, type: 1 },
    { time: 4.962, lane: 3, type: 1 },
    { time: 5.484, lane: 3, type: 1 },
    { time: 5.486, lane: 4, type: 0 },
    { time: 6.647, lane: 0, type: 1 },
    { time: 7.134, lane: 1, type: 0 },
    { time: 7.587, lane: 3, type: 2 },
    { time: 7.604, lane: 4, type: 0 },
    { time: 7.82, lane: 3, type: 0 },
    { time: 7.844, lane: 4, type: 1 },
    { time: 8.082, lane: 3, type: 0 },
    { time: 8.083, lane: 4, type: 0 },
    { time: 8.341, lane: 3, type: 2 },
    { time: 8.654, lane: 3, type: 1 },
    { time: 9.348, lane: 0, type: 1 },
    { time: 9.977, lane: 1, type: 2 },
    { time: 10.458, lane: 2, type: 2 },
    { time: 10.992, lane: 3, type: 1 },
    { time: 11.51, lane: 4, type: 2 },
    { time: 11.702, lane: 4, type: 2 },
    { time: 11.965, lane: 4, type: 0 },
    { time: 12.439, lane: 4, type: 1 },
    { time: 13.153, lane: 3, type: 0 },
    { time: 13.935, lane: 0, type: 0 },
    { time: 14.353, lane: 1, type: 0 },
    { time: 14.749, lane: 2, type: 1 },
    { time: 15.269, lane: 4, type: 0 },
    { time: 15.501, lane: 4, type: 0 },
    { time: 15.741, lane: 4, type: 2 },
    { time: 16.004, lane: 4, type: 0 },
    { time: 16.251, lane: 4, type: 2 },
    { time: 16.485, lane: 3, type: 2 },
    { time: 16.758, lane: 1, type: 2 },
    { time: 16.997, lane: 0, type: 0 },
    { time: 17.689, lane: 4, type: 0 },
    { time: 17.928, lane: 3, type: 0 },
    { time: 18.213, lane: 0, type: 1 },
    { time: 18.282, lane: 1, type: 1 },
    { time: 18.808, lane: 4, type: 0 },
    { time: 19.337, lane: 3, type: 0 },
    { time: 19.775, lane: 4, type: 0 },
    { time: 21.041, lane: 1, type: 1 },
    { time: 21.53, lane: 0, type: 1 },
    { time: 22.038, lane: 1, type: 2 },
    { time: 22.277, lane: 3, type: 0 },
    { time: 23.434, lane: 4, type: 2 },
    { time: 23.92, lane: 3, type: 0 },
    { time: 24.424, lane: 1, type: 2 },
    { time: 25.331, lane: 4, type: 0 },
    { time: 25.628, lane: 3, type: 0 },
    { time: 26.126, lane: 3, type: 0 },
    { time: 26.218, lane: 3, type: 0 },
    { time: 26.298, lane: 3, type: 0 },
    { time: 26.325, lane: 4, type: 1 },
    { time: 26.837, lane: 3, type: 2 },
    { time: 27.288, lane: 1, type: 1 },
    { time: 27.72, lane: 0, type: 2 },
    { time: 28.009, lane: 1, type: 2 },
    { time: 29.131, lane: 3, type: 2 },
    { time: 30.121, lane: 3, type: 1 },
    { time: 30.643, lane: 3, type: 2 },
    { time: 31.598, lane: 4, type: 2 },
    { time: 32.33, lane: 1, type: 2 },
    { time: 32.962, lane: 0, type: 2 },
    { time: 33.932, lane: 3, type: 2 },
    { time: 34.412, lane: 1, type: 1 },
    { time: 35.408, lane: 4, type: 2 },
    { time: 36.08, lane: 3, type: 2 },
            ]
        };
        
        const keyMaps = {
            left: { 'a': 0, 's': 1, 'd': 2, 'f': 3, ' ': 4 },
            right: { ' ': 0, 'j': 1, 'k': 2, 'l': 3, ';': 4 }
        };
        let currentKeyMap = null;
        let keyMapDisplay = {};

        let audio, beatmap;
        let notes = [], score = 0, combo = 0, particles = [];
        let laneFlashes = [0, 0, 0, 0, 0];
        let isGameRunning = false;
        const noteSpeed = 3;
        let currentSong, currentStage = 0;
        let currentPlayStyle;

        const SABLE_COLORS = {
            base: ['#5a8a56', '#5D4037', '#e7c060'],
            light: ['#83b97e', '#8d6e63', '#f8e5ab'],
            shadow: ['#4a7047', '#4a332c', '#c7a340']
        };
        
        function generateDifficulty(baseBeatmap, stage) {
            if (stage === 2) return baseBeatmap; // HARD
            const ratio = stage === 1 ? 0.75 : 0.5; // NORMAL : EASY
            return baseBeatmap.filter((_, index) => index % Math.round(1 / ratio) === 0);
        }

        function showView(view) {
            mainView.innerHTML = view;
            uiLayer.classList.remove('hidden');
            attachButtonListeners();
        }

        function showSongSelect() {
            currentStage = 0;
            const view = `
                <p>プレイする曲を選んでください</p>
                <button class="ui-button" data-action="select-song" data-song="sakusaku">サクサク冒険</button>
                <button class="ui-button" data-action="select-song" data-song="mochimochi">もちもちリラックス</button>
            `;
            showView(view);
        }
        
        function showStyleSelect() {
            const view = `
                <p>プレイスタイルを選んでください</p>
                <button class="ui-button" data-action="select-style" data-style="left">左手でプレイ</button>
                <button class="ui-button" data-action="select-style" data-style="right">右手でプレイ</button>
                <button class="ui-button" data-action="select-style" data-style="tap">タップでプレイ</button>
                <button class="ui-button" data-action="back-to-song-select">曲選択に戻る</button>
            `;
            showView(view);
        }

        function attachButtonListeners() {
            document.querySelectorAll('[data-action]').forEach(button => {
                button.onclick = (e) => {
                    const { action, song, style } = e.target.dataset;
                    switch (action) {
                        case 'select-song':
                            currentSong = song;
                            showStyleSelect();
                            break;
                        case 'select-style':
                            currentPlayStyle = style;
                            prepareGame();
                            break;
                        case 'retry':
                            showStyleSelect();
                            break;
                        case 'back-to-song-select': showSongSelect(); break;
                    }
                };
            });
        }
        
        function prepareGame() {
            if (currentPlayStyle === 'left' || currentPlayStyle === 'right') {
                currentKeyMap = keyMaps[currentPlayStyle];
                keyMapDisplay = {};
                for(const key in currentKeyMap) { keyMapDisplay[currentKeyMap[key]] = (key === ' ' ? 'SPACE' : key.toUpperCase()); }
            } else {
                currentKeyMap = null;
                keyMapDisplay = {};
            }
            
            beatmap = generateDifficulty(masterBeatmaps[currentSong], currentStage);
            audio = new Audio(`./${currentSong}.mp3`);
            audio.preload = "auto";
            showView(`<p>STAGE ${currentStage + 1}<br>読み込み中...</p>`);
            audio.addEventListener('canplaythrough', startGame, { once: true });
            audio.load();
        }

        function startGame() {
            score = 0; combo = 0; notes = [];
            isGameRunning = true;
            uiLayer.classList.add('hidden');
            beatmap.forEach(createNote);
            audio.currentTime = 0;
            audio.play();
            gameLoop();
        }

        function createNote(noteData) {
            notes.push({ ...noteData, y: -NOTE_HEIGHT, time: noteData.time, isHit: false });
        }

        function gameLoop() {
            if (!isGameRunning) return;
            const currentTime = audio.currentTime;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLanes();
            drawJudgementLine();
            notes.forEach(note => {
                if (!note.isHit) {
                    const timeUntilHit = note.time - currentTime;
                    note.y = JUDGEMENT_LINE_Y - (timeUntilHit * 60 * noteSpeed);
                    drawNote(note);
                    if (timeUntilHit < -0.2) { note.isHit = true; showFeedback('MISS'); resetCombo(); }
                }
            });
            notes = notes.filter(note => !note.isHit || note.y <= canvas.height);
            particles.forEach((p, i) => { p.update(); p.draw(); if (p.alpha <= 0) particles.splice(i, 1); });
            if (!audio.paused && audio.ended) {
                finishStage();
            } else {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function finishStage() {
            isGameRunning = false;
            const clearThreshold = beatmap.length * 300 * 0.7; // クリア条件を少し緩和
            const isClear = score >= clearThreshold;

            if (isClear) {
                if (currentStage < 2) { // まだ次のステージがある場合
                    currentStage++;
                    showView(`<div><p>STAGE CLEAR!</p><p>次のステージに進みます...</p></div>`);
                    setTimeout(prepareGame, 2500); // 2.5秒後に次のステージへ
                } else { // 全ステージクリア
                    showEndScreen(true);
                }
            } else { // ステージ失敗
                showEndScreen(false);
            }
        }
        
        function showEndScreen(isTourClear) {
             const message = isTourClear ? "TOUR CLEAR! <br> 全ステージ制覇おめでとう！" : "STAGE FAILED...";
             const view = `
                <div>
                    <p>${message}</p>
                    <p>SCORE: ${score}</p>
                    <button class="ui-button" data-action="retry">もう一度挑戦</button>
                    <button class="ui-button" data-action="back-to-song-select">曲選択に戻る</button>
                </div>
            `;
            showView(view);
        }

        function drawLanes() {
            for (let i = 0; i < LANES; i++) {
                ctx.fillStyle = (i % 2 === 0) ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.2)';
                ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                if (laneFlashes[i] > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${laneFlashes[i]})`;
                    ctx.fillRect(i * LANE_WIDTH, 0, LANE_WIDTH, canvas.height);
                    laneFlashes[i] -= 0.05;
                }
            }
        }

        function drawJudgementLine() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0, JUDGEMENT_LINE_Y, canvas.width, 3);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, JUDGEMENT_LINE_Y - 30, canvas.width, 60);
            
            if (currentKeyMap) {
                ctx.font = 'bold 20px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                for (let i = 0; i < LANES; i++) {
                    const key = keyMapDisplay[i] || '';
                    ctx.fillText(key, i * LANE_WIDTH + LANE_WIDTH / 2, JUDGEMENT_LINE_Y + 30);
                }
            }
        }

        function drawNote(note) {
            const x = note.lane * LANE_WIDTH;
            const w = LANE_WIDTH - 10;
            const h = NOTE_HEIGHT;
            const y = note.y;
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x + 8, y + 8, w, h);
            ctx.fillStyle = SABLE_COLORS.base[note.type];
            ctx.fillRect(x + 5, y, w, h);
            ctx.fillStyle = SABLE_COLORS.light[note.type];
            ctx.fillRect(x + 5, y, w, h/3);
            ctx.fillStyle = SABLE_COLORS.shadow[note.type];
            ctx.fillRect(x + 5, y + h - 4, w, 4);
        }

        function handleInput(lane) {
            if (!isGameRunning) return;
            const targetTime = audio.currentTime;
            let bestNoteIndex = -1;
            let minDiff = Infinity;
            notes.forEach((note, index) => {
                if (note.lane === lane && !note.isHit) {
                    const diff = Math.abs(note.time - targetTime);
                    if (diff < minDiff) { minDiff = diff; bestNoteIndex = index; }
                }
            });
            laneFlashes[lane] = 0.5;
            if (bestNoteIndex !== -1 && minDiff < 0.2) {
                const note = notes[bestNoteIndex];
                note.isHit = true;
                if (minDiff < 0.08) { score += 300 + combo; combo++; showFeedback('PERFECT'); }
                else if (minDiff < 0.15) { score += 100; combo++; showFeedback('GOOD'); }
                else { resetCombo(); showFeedback('BAD'); }
                createParticles(lane * LANE_WIDTH + LANE_WIDTH / 2, JUDGEMENT_LINE_Y);
            }
            updateUI();
        }
        
        function resetCombo() { combo = 0; }
        function updateUI() { scoreEl.textContent = score; comboEl.textContent = combo; }

        function showFeedback(text) {
            feedbackText.textContent = text;
            feedbackText.className = 'show';
            setTimeout(() => feedbackText.classList.remove('show'), 300);
        }
        
        function createParticles(x, y) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5 - 2,
                    alpha: 1, color: `hsl(${Math.random() * 60 + 30}, 100%, 70%)`,
                    update() { this.x += this.vx; this.y += this.vy; this.alpha -= 0.04; },
                    draw() {
                        ctx.globalAlpha = this.alpha;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                });
            }
        }

        document.addEventListener('keydown', (e) => {
            if (currentKeyMap) {
                const key = e.key === ' ' ? ' ' : e.key.toLowerCase();
                if (currentKeyMap[key] !== undefined) handleInput(currentKeyMap[key]);
            }
        });

        function handlePointerInput(event) {
            event.preventDefault();
            if (currentKeyMap) return;
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const touchX = clientX - rect.left;
            const lane = Math.floor(touchX / (rect.width / LANES));
            if (lane >= 0 && lane < LANES) handleInput(lane);
        }
        
        canvas.addEventListener('touchstart', handlePointerInput, { passive: false });
        canvas.addEventListener('mousedown', handlePointerInput);
        
        showSongSelect();
    });
    </script>
</body>
</html>
